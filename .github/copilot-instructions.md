# GitHub Copilot Instructions for go-discord-chatgpt

This document provides instructions and context for GitHub Copilot to effectively assist with the development of the `go-discord-chatgpt` project.

## Project Overview

`go-discord-chatgpt` is a Discord bot written in Go. It uses the Arikawa library for Discord API interaction, Uber Fx for dependency injection and application lifecycle management, and integrates with OpenAI's GPT models. The primary goal is to provide slash command functionalities, including interactions with ChatGPT, such as the `/chat` command.

## Key Technologies & Libraries

*   **Go**: The primary programming language.
*   **Arikawa (v3)**: Go library for the Discord API. Used for session management, event handling, and command registration. (See also: [`arikawa.instructions.md`](.github/instructions/arikawa.instructions.md) for detailed guidance on using Arikawa).
*   **Uber Fx**: Dependency injection framework. Manages the application's lifecycle and the creation and wiring of components (services, configuration, logger, OpenAI client, cache, etc.).
*   **Zap**: Structured logging library. Used for all application logging, including Fx's internal logs.
*   **YAML V3**: For parsing the `config.yaml` file.
*   **Testify (mock, require, assert)**: For writing unit tests and making assertions.
*   **Mockery (vektra/mockery)**: For generating mock implementations of interfaces, configured via `.mockery.yml`.
*   **go-openai (sashabaranov/go-openai)**: Go client library for the OpenAI API.
*   **golang-lru (hashicorp/golang-lru/v2)**: LRU cache implementation, used for caching OpenAI message history.

## Project Structure

```
.
├── config.yaml             # Application configuration
├── config.example.yaml     # Example configuration file
├── go.mod                  # Go module definition
├── go.sum                  # Go module checksums
├── LICENSE                 # Project license
├── README.md               # Project README
├── .mockery.yml            # Configuration for Mockery mock generation.
├── cmd/
│   └── main.go             # Main application entry point, Fx setup, and lifecycle management.
├── internal/
│   ├── bot/
│   │   ├── bot.go          # Core bot service, handles startup/shutdown logic, interaction event routing.
│   │   └── handlers.go     # Interaction event handlers (e.g., for slash commands and thread messages).
│   ├── chat/               # Modular chat service architecture with specialized components
│   │   ├── service.go      # Main chat service orchestrator that coordinates all chat components.
│   │   ├── ai_provider.go  # AIProvider interface and OpenAI implementation for chat completions.
│   │   ├── conversation_store.go # ConversationStore interface for managing conversation history and caching.
│   │   ├── interaction_manager.go # DiscordInteractionManager for Discord API interactions (responses, threads, typing).
│   │   ├── model_selector.go # ModelSelector interface for choosing AI models based on user preferences.
│   │   ├── summary_parser.go # SummaryParser interface for parsing thread summary messages to extract metadata.
│   │   └── util.go         # Utility functions: GetUserDisplayName, SanitizeOpenAIName, MakeThreadName, SendLongMessage.
│   ├── commands/
│   │   ├── chat.go         # Implementation of the `/chat` command, which delegates to the `chat.Service`.
│   │   ├── command_loader.go # CommandManager: loads commands from Fx, registers/unregisters with Discord.
│   │   ├── command_loader_test.go # Unit tests for CommandManager.
│   │   ├── command.go      # Defines the `Command` interface that all slash commands must implement.
│   │   ├── mocks_test.go   # Mocks generated by Mockery (e.g., for Command interface).
│   │   ├── ping.go         # Implementation of the `/ping` command.
│   │   └── version.go      # Implementation of the `/version` command.
│   ├── config/
│   │   └── config.go       # Configuration struct and loading logic.
│   └── gpt/
│       ├── cache.go        # LRU Cache implementation for OpenAI messages (MessagesCache).
│       └── negative_cache.go # LRU cache for threads that should be ignored (NegativeThreadCache).

```

## Core Architectural Decisions & Patterns

1.  **Dependency Injection with Uber Fx**:
    *   The application's components (config, logger, Discord session, OpenAI client, message cache, negative thread cache, **chat service components**, command manager, bot service, commands like [`ChatCommand`](internal/commands/chat.go)) are managed by Fx.
    *   **Chat Service Components**: The chat system is now modular with several specialized services:
        *   [`chat.Service`](internal/chat/service.go) - Main orchestrator that coordinates all chat interactions
        *   [`chat.AIProvider`](internal/chat/ai_provider.go) - Interface for AI completions (OpenAI implementation)
        *   [`chat.ConversationStore`](internal/chat/conversation_store.go) - Manages conversation history and caching
        *   [`chat.DiscordInteractionManager`](internal/chat/interaction_manager.go) - Handles Discord API interactions
        *   [`chat.ModelSelector`](internal/chat/model_selector.go) - Selects appropriate AI models
        *   [`chat.SummaryParser`](internal/chat/summary_parser.go) - Parses thread summary messages
    *   Providers for these components are defined in `cmd/main.go` using a modular approach where the [`chat.ConversationStore`](internal/chat/conversation_store.go) is created via a custom provider function (`newConversationStoreProvider`) that combines multiple dependencies.
    *   Fx handles the lifecycle (start/stop) of these components. For example, the Discord session is opened on start and closed on stop, and commands are registered/unregistered accordingly.

2.  **Configuration Management**:
    *   Configuration is loaded from `config.yaml` into the `config.Config` struct ([`internal/config/config.go`](internal/config/config.go)).
    *   This includes Discord settings (bot token, app ID, guild IDs, interaction timeout) and OpenAI settings (API key, preferred models, message cache size, negative thread cache size, max concurrent requests).
    *   The path to `config.yaml` is supplied to Fx in [`cmd/main.go`](cmd/main.go).
    *   The `*config.Config` object is then available for injection into other components. For example, `discord.interaction_timeout_seconds` is used by the [`Bot`](internal/bot/bot.go) service, `openai.message_cache_size` configures the conversation store cache, and `openai.negative_thread_cache_size` configures the negative thread cache.

3.  **Logging**:
    *   Zap is used for structured logging.
    *   A `*zap.Logger` is configured and provided by Fx.
    *   Fx's internal logging is also adapted to use this Zap logger via the `zapFxPrinter` in `cmd/main.go`.

4.  **Command Handling**:
    *   **Interface**: All slash commands implement the `commands.Command` interface defined in `internal/commands/command.go`. This interface specifies methods like `Name()`, `Description()`, `Options()`, and `Execute()`.
    *   **Constructors & Fx Groups**: Each command (e.g., [`PingCommand`](internal/commands/ping.go), [`VersionCommand`](internal/commands/version.go), [`ChatCommand`](internal/commands/chat.go)) has a constructor function (e.g., `NewPingCommand() commands.Command`). The [`ChatCommand`](internal/commands/chat.go) now takes the [`chat.Service`](internal/chat/service.go) as a dependency.
    *   **Fx Provisioning**: These constructors are provided to Fx in `cmd/main.go` and tagged with `fx.ResultTags(\`group:"commands"\`)`.
    *   **CommandManager**: The [`commands.CommandManager`](internal/commands/command_loader.go) ([`internal/commands/command_loader.go`](internal/commands/command_loader.go)) receives all [`commands.Command`](internal/commands/command.go) implementations from the "commands" Fx group.
    *   **Registration**: On startup, [`CommandManager.RegisterCommands()`](internal/commands/command_loader.go) iterates through the loaded commands and registers them with Discord (globally or for specific guilds listed in `config.yaml`). It unregisters them on shutdown.
    *   **Dispatch**: The [`Bot`](internal/bot/bot.go) service ([`internal/bot/bot.go`](internal/bot/bot.go)) receives interaction create events from Arikawa. The [`handleInteraction`](internal/bot/handlers.go) function ([`internal/bot/handlers.go`](internal/bot/handlers.go)) uses the [`CommandManager`](internal/commands/command_loader.go) to find the appropriate command handler based on the interaction data and then executes it. The [`ChatCommand`](internal/commands/chat.go) delegates its core execution logic to the [`chat.Service`](internal/chat/service.go). Additionally, the bot handles thread message events via the [`handleMessageCreate`](internal/bot/handlers.go) function, which also delegates to the [`chat.Service`](internal/chat/service.go) for thread message processing.

5.  **Discord Session**:
    *   The Arikawa `*session.Session` is created and managed by Fx ([`NewSession`](cmd/main.go) in [`cmd/main.go`](cmd/main.go)).
    *   Its lifecycle (Open/Close) is tied to Fx's OnStart/OnStop hooks.
    *   Intents are configured within the `NewSession` provider.

6.  **Testing Strategy**:
    *   Unit tests are written using the `testify` suite (`assert`, `require`).
    *   Testing should primarily focus on the public interfaces of components.
    *   Mocks, generated with `vektra/mockery` (configured via `.mockery.yml`), should be used judiciously and only when necessary to isolate the unit under test. Avoid overuse of mocks.
    *   Test files should follow the Go convention of `*_test.go` (e.g., [`command_loader_test.go`](internal/commands/command_loader_test.go)). For black-box testing, they are often placed in a separate test package (e.g., `package commands_test` to test the `commands` package).
    *   Tests for components like [`CommandManager`](internal/commands/command_loader.go) ([`internal/commands/command_loader_test.go`](internal/commands/command_loader_test.go)) utilize these practices.

7.  **OpenAI Integration & Caching**:
    *   **OpenAI Client**: An `*openai.Client` is created and managed by Fx ([`NewOpenAIClient`](cmd/main.go) in [`cmd/main.go`](cmd/main.go)), configured with the API key from `config.yaml`.
    *   **Specialized Components**: Various specialized components for the chat system are now provided individually:
        *   [`gpt.MessagesCache`](internal/gpt/cache.go) - LRU cache for OpenAI message history, configured by `openai.message_cache_size`
        *   [`gpt.NegativeThreadCache`](internal/gpt/negative_cache.go) - LRU cache for threads to ignore, configured by `openai.negative_thread_cache_size`
        *   [`chat.ConversationStore`](internal/chat/conversation_store.go) - Created via a custom provider that creates internal caches based on configuration settings
    *   These components are available for injection into services that require interaction with the OpenAI API or its message history, primarily the **[`chat.Service`](internal/chat/service.go)** (which is then used by commands like [`ChatCommand`](internal/commands/chat.go)).

## Development Guidelines & Preferences

*   **Modularity**: Keep components decoupled and use Fx for wiring them together.
*   **Interfaces**: Use interfaces (like `commands.Command`) to define contracts between components.
*   **Structured Logging**: Use Zap for all logging. Provide context with logs where possible.
*   **Commenting**: Avoid redundant and long comments. Only comment where necessary to explain complex logic or non-obvious decisions.
*   **Error Handling**: Handle errors explicitly. Fx's lifecycle management will also report errors during startup/shutdown.
*   **Configuration-Driven**: Make behavior configurable via [`config.yaml`](config.yaml) where appropriate (e.g., guild IDs, OpenAI models, cache size, interaction timeouts).
*   **Go Best Practices**: Adhere to the guidelines outlined in [`golang.instructions.md`](.github/instructions/golang.instructions.md) for consistent and high-quality Go code.
*   **Testing**:
    *   Write unit tests for individual components and commands, focusing on public interfaces.
    *   Utilize the `testify` suite for assertions.
    *   Employ `mockery` for generating mocks, but only when essential for test isolation. Prefer real implementations or test doubles where feasible.
    *   Ensure test files are named with the `_test.go` suffix and organized appropriately (e.g., in a `package <name>_test`).
    *   Fx's structure facilitates mocking dependencies when necessary.

## Current Focus & Future Considerations

*   **Enhancing ChatGPT Commands**: Building upon the existing [`/chat`](internal/commands/chat.go) command and its underlying **[`chat.Service`](internal/chat/service.go)**, further refining context management (e.g., using the [`MessagesCache`](internal/gpt/cache.go) within the **[`chat.Service`](internal/chat/service.go)** more extensively for follow-up messages), prompt engineering capabilities, and exploring new GPT-powered features.
*   **Improving User Experience**: Continuously expanding error handling, providing clearer user feedback in Discord, especially for API interactions (like OpenAI calls managed by the **[`chat.Service`](internal/chat/service.go)** for the [`ChatCommand`](internal/commands/chat.go)) and longer operations.
*   **Comprehensive Testing**: Increasing test coverage, particularly with integration tests for command flows involving OpenAI and other external services. The [`ChatCommand`](internal/commands/chat.go) and particularly the **[`chat.Service`](internal/chat/service.go)** are key candidates for such tests.
*   **Configuration Flexibility**: Exploring more dynamic configuration options or in-Discord configuration commands.

This document should help Copilot understand the project's design and assist in a way that aligns with these established patterns.
